1. Can you think of why we use fork/execvp instead of just calling execvp directly? What value do you think the fork provides?
                                                                                                                                                            Answer:  Fork is important here because it allows the parent to continue executing while the child runs its command. This is essential for our shell because it keeps the shell running even when executing external commands.                                                                                                                                                                                                                                                      2. What happens if the fork() system call fails? How does your implementation handle this scenario?                                                                                                                                                                                                                     Answer: If fork() fails, I return ERR_EXEC_CMD. This is essential in case the command given doesn't exist or is invalid.                                                                                                                                                                                                3. How does execvp() find the command to execute? What system environment variable plays a role in this process?                                                                                                                                                                                                        Answer: execvp() works by looping through all the directories listed in the PATH environment variable. If it finds the command, it loads and runs it with the arguments given.                                                                                                                                                                                                                                                                                                      4. What is the purpose of calling wait() in the parent process after forking? What would happen if we didnâ€™t call it?                                                                                                                                                                                                   Answer: We call wait() to ensure the child process finishes running before the parent process continues executing. If this isn't done, it could lead to uncontrolled or unpredictable behavior between the child and parent processes.

5. In the referenced demo code we used WEXITSTATUS(). What information does this provide, and why is it important?                                                                                                                                                                                                      Answer: This retrieves the child exit staus before he child terminates. It is important because it allows to confirm if the child successfully executed.

6. Describe how your implementation of build_cmd_buff() handles quoted arguments. Why is this necessary?            

Answer: My build_cmd_buff handles quoted arguments by initializing a checker and updating it each time we encounter a ". The checker then serves as a condition to determine whether to delete whitespaces in the string or not.       

7. What changes did you make to your parsing logic compared to the previous assignment? Were there any unexpected challenges in refactoring your old code?                                                                                                                                                              Answer: For this assignment, I didn't use strtok to split the string, mainly because we weren't dealing with pipes, and using it could complicate my handling of quoted arguments. There weren't many challenges, just slight differences, such as how I am updating the new struct with data.                                                                                                                                                                                      For this quesiton, you need to do some research on Linux signals. You can use this google search to get started.

8. a. What is the purpose of signals in a Linux system, and how do they differ from other forms of interprocess communication (IPC)?

Answer: Signals are used to communicate between processes. They differe from IPC because tehy do not require any specific connection between processes

8. b. Find and describe three commonly used signals (e.g., SIGKILL, SIGTERM, SIGINT). What are their typical use cases?

Answer: SIGINT - A signal generated when control-c is pressed. It requests termination
SIGTERM - It is a request to the program to terminate
SIGKILL - Forcefully terminates a process

8. c. What happens when a process receives SIGSTOP? Can it be caught or ignored like SIGINT? Why or why not?
This pauses a process. It cannot be caught or ignored. It is designed to be stop a process without been overriten

